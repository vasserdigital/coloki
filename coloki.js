// Default values - adjust these to change starting settings
const DEFAULT_COLOR = "#21877F";
const DEFAULT_LIGHTEN_INTENSITY = 0.14;
const DEFAULT_DARKEN_INTENSITY = 0.15;
const DEFAULT_SATURATION_AMOUNT = 0.6;  // 0.0 = no preservation, 1.0 = full preservation
const DEFAULT_LIGHTEN_SATURATION_BOOST = 0.25;  // Boost saturation on lighter colors (0.0-0.5)
const DEFAULT_DARKEN_SATURATION_REDUCE = 0.45;  // Reduce saturation on darker colors (0.0-0.5)

// Curve adjustments - reduce extreme effects on the most extreme colors
const CURVE_EXTREME = 0.85;  // Effect on most extreme colors (50 and 950): 0.5-1.0
const CURVE_SECOND = 0.9;   // Effect on second extreme colors (100 and 900): 0.5-1.0

// DOM elements
const colorPicker = document.getElementById("primary-color");
const swatches = document.querySelectorAll(".generator div");
const lightenSlider = document.getElementById("lighten-step");
const darkenSlider = document.getElementById("darken-step");
const saturationSlider = document.getElementById("saturation-amount");
const lightenSaturationSlider = document.getElementById("lighten-saturation-boost");
const darkenSaturationSlider = document.getElementById("darken-saturation-reduce");
const lightenValueDisplay = document.getElementById("lighten-value");
const darkenValueDisplay = document.getElementById("darken-value");
const saturationValueDisplay = document.getElementById("saturation-value");
const lightenSaturationValueDisplay = document.getElementById("lighten-saturation-value");
const darkenSaturationValueDisplay = document.getElementById("darken-saturation-value");
const cssCodeBlock = document.querySelector(".autogenerated-css");

// Initialize with defaults
colorPicker.value = DEFAULT_COLOR;
lightenSlider.value = DEFAULT_LIGHTEN_INTENSITY;
darkenSlider.value = DEFAULT_DARKEN_INTENSITY;
saturationSlider.value = DEFAULT_SATURATION_AMOUNT;
lightenSaturationSlider.value = DEFAULT_LIGHTEN_SATURATION_BOOST;
darkenSaturationSlider.value = DEFAULT_DARKEN_SATURATION_REDUCE;
lightenValueDisplay.textContent = DEFAULT_LIGHTEN_INTENSITY;
darkenValueDisplay.textContent = DEFAULT_DARKEN_INTENSITY;
saturationValueDisplay.textContent = DEFAULT_SATURATION_AMOUNT;
lightenSaturationValueDisplay.textContent = DEFAULT_LIGHTEN_SATURATION_BOOST;
darkenSaturationValueDisplay.textContent = DEFAULT_DARKEN_SATURATION_REDUCE;

updateAll({ target: colorPicker });

// Add event listeners
colorPicker.addEventListener("input", updateAll);
lightenSlider.addEventListener("input", (e) => {
  lightenValueDisplay.textContent = e.target.value;
  updateAll({ target: colorPicker });
});
darkenSlider.addEventListener("input", (e) => {
  darkenValueDisplay.textContent = e.target.value;
  updateAll({ target: colorPicker });
});
saturationSlider.addEventListener("input", (e) => {
  saturationValueDisplay.textContent = e.target.value;
  updateAll({ target: colorPicker });
});
lightenSaturationSlider.addEventListener("input", (e) => {
  lightenSaturationValueDisplay.textContent = e.target.value;
  updateAll({ target: colorPicker });
});
darkenSaturationSlider.addEventListener("input", (e) => {
  darkenSaturationValueDisplay.textContent = e.target.value;
  updateAll({ target: colorPicker });
});

function updateAll(event) {
  const base = event.target.value;
  const primaryIndex = 7; // primary-600 is at index 7

  // Read values from sliders
  const lightenStep = parseFloat(lightenSlider.value);
  const darkenStep = parseFloat(darkenSlider.value);
  const saturationAmount = parseFloat(saturationSlider.value);
  const lightenSaturationBoost = parseFloat(lightenSaturationSlider.value);
  const darkenSaturationReduce = parseFloat(darkenSaturationSlider.value);

  // Color step names for CSS generation
  const steps = [50, 100, 150, 200, 300, 400, 500, 600, 700, 800, 850, 900, 950];
  const colors = [];

  swatches.forEach((div, index) => {
    let finalColor;

    if (index === primaryIndex) {
      // Index 7 (primary-600): use the base color directly
      finalColor = base;
    } else if (index < primaryIndex) {
      // Indices 0-6 (50-500): progressively lighter
      const distance = primaryIndex - index; // 7, 6, 5, 4, 3, 2, 1

      // Apply curve: reduce effect on most extreme colors
      let curve = 1.0;
      if (distance === 7) curve = CURVE_EXTREME;  // 50
      else if (distance === 6) curve = CURVE_SECOND; // 100

      const lightenAmount = lightenStep * distance * curve;
      let lightenedColor = lightenColor(base, lightenAmount);

      // Preserve saturation by blending with warm off-white multiplication
      if (saturationAmount > 0) {
        const multipliedColor = multiplyColor(lightenedColor, "#FFFCF0");
        lightenedColor = blendColors(lightenedColor, multipliedColor, saturationAmount);
      }

      // Boost saturation on lighter colors (more boost as we get lighter)
      const saturationBoost = lightenSaturationBoost * (distance / 7) * curve;
      finalColor = adjustSaturation(lightenedColor, saturationBoost);
    } else {
      // Indices 8-12 (700-950): progressively darker
      const distance = index - primaryIndex; // 1, 2, 3, 4, 5

      // Apply curve: reduce effect on most extreme colors
      let curve = 1.0;
      if (distance === 5) curve = CURVE_EXTREME;  // 950
      else if (distance === 4) curve = CURVE_SECOND; // 900

      const darkenAmount = darkenStep * distance * curve;
      let darkenedColor = darkenColor(base, darkenAmount);

      // Reduce saturation on darker colors (more reduction as we get darker)
      const saturationReduce = darkenSaturationReduce * (distance / 5) * curve;
      finalColor = adjustSaturation(darkenedColor, -saturationReduce);
    }

    div.style.backgroundColor = finalColor;
    div.innerHTML = `<span>${finalColor.toUpperCase()}</span>`;
    colors.push(finalColor.toUpperCase());
  });

  // Update CSS code block
  updateCSSOutput(steps, colors);
}

function updateCSSOutput(steps, colors) {
  let css = "";
  steps.forEach((step, index) => {
    const spacing = step < 100 ? "  " : step < 1000 ? " " : "";
    css += `--coloki-${step}:${spacing} ${colors[index]};\n`;
  });
  cssCodeBlock.textContent = css.trim();
}

function scaleColor(hex, factor) {
  const r = clamp(parseInt(hex.slice(1, 3), 16) * factor);
  const g = clamp(parseInt(hex.slice(3, 5), 16) * factor);
  const b = clamp(parseInt(hex.slice(5, 7), 16) * factor);

  return (
    "#" +
    r.toString(16).padStart(2, "0") +
    g.toString(16).padStart(2, "0") +
    b.toString(16).padStart(2, "0")
  );
}

function clamp(value) {
  return Math.max(0, Math.min(255, Math.round(value)));
}

function lightenColor(hex, amount) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);

  // Mix with white
  const newR = clamp(r + (255 - r) * amount);
  const newG = clamp(g + (255 - g) * amount);
  const newB = clamp(b + (255 - b) * amount);

  return (
    "#" +
    newR.toString(16).padStart(2, "0") +
    newG.toString(16).padStart(2, "0") +
    newB.toString(16).padStart(2, "0")
  );
}

function darkenColor(hex, amount) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);

  // Mix with black
  const newR = clamp(r * (1 - amount));
  const newG = clamp(g * (1 - amount));
  const newB = clamp(b * (1 - amount));

  return (
    "#" +
    newR.toString(16).padStart(2, "0") +
    newG.toString(16).padStart(2, "0") +
    newB.toString(16).padStart(2, "0")
  );
}

function multiplyColor(hex1, hex2) {
  // Multiply two colors together (like Photoshop multiply blend mode)
  // This preserves saturation when lightening by mixing with a warm color
  const r1 = parseInt(hex1.slice(1, 3), 16) / 255;
  const g1 = parseInt(hex1.slice(3, 5), 16) / 255;
  const b1 = parseInt(hex1.slice(5, 7), 16) / 255;

  const r2 = parseInt(hex2.slice(1, 3), 16) / 255;
  const g2 = parseInt(hex2.slice(3, 5), 16) / 255;
  const b2 = parseInt(hex2.slice(5, 7), 16) / 255;

  const newR = clamp((r1 * r2) * 255);
  const newG = clamp((g1 * g2) * 255);
  const newB = clamp((b1 * b2) * 255);

  return (
    "#" +
    newR.toString(16).padStart(2, "0") +
    newG.toString(16).padStart(2, "0") +
    newB.toString(16).padStart(2, "0")
  );
}

function blendColors(hex1, hex2, amount) {
  // Blend between two colors
  // amount = 0: returns hex1, amount = 1: returns hex2
  const r1 = parseInt(hex1.slice(1, 3), 16);
  const g1 = parseInt(hex1.slice(3, 5), 16);
  const b1 = parseInt(hex1.slice(5, 7), 16);

  const r2 = parseInt(hex2.slice(1, 3), 16);
  const g2 = parseInt(hex2.slice(3, 5), 16);
  const b2 = parseInt(hex2.slice(5, 7), 16);

  const newR = clamp(r1 + (r2 - r1) * amount);
  const newG = clamp(g1 + (g2 - g1) * amount);
  const newB = clamp(b1 + (b2 - b1) * amount);

  return (
    "#" +
    newR.toString(16).padStart(2, "0") +
    newG.toString(16).padStart(2, "0") +
    newB.toString(16).padStart(2, "0")
  );
}

function hexToHSL(hex) {
  const r = parseInt(hex.slice(1, 3), 16) / 255;
  const g = parseInt(hex.slice(3, 5), 16) / 255;
  const b = parseInt(hex.slice(5, 7), 16) / 255;

  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const diff = max - min;

  let h = 0;
  let s = 0;
  const l = (max + min) / 2;

  if (diff !== 0) {
    s = l > 0.5 ? diff / (2 - max - min) : diff / (max + min);

    switch (max) {
      case r: h = ((g - b) / diff + (g < b ? 6 : 0)) / 6; break;
      case g: h = ((b - r) / diff + 2) / 6; break;
      case b: h = ((r - g) / diff + 4) / 6; break;
    }
  }

  return [h, s, l];
}

function HSLToHex(h, s, l) {
  const hueToRgb = (p, q, t) => {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1/6) return p + (q - p) * 6 * t;
    if (t < 1/2) return q;
    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
    return p;
  };

  let r, g, b;
  if (s === 0) {
    r = g = b = l;
  } else {
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hueToRgb(p, q, h + 1/3);
    g = hueToRgb(p, q, h);
    b = hueToRgb(p, q, h - 1/3);
  }

  return (
    "#" +
    clamp(r * 255).toString(16).padStart(2, "0") +
    clamp(g * 255).toString(16).padStart(2, "0") +
    clamp(b * 255).toString(16).padStart(2, "0")
  );
}

function adjustSaturation(hex, amount) {
  // Adjust saturation: positive values increase, negative decrease
  const [h, s, l] = hexToHSL(hex);
  const newS = Math.max(0, Math.min(1, s + amount));
  return HSLToHex(h, newS, l);
}
